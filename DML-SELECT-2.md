<h1>WINDOW 함수 이용 검색</h1>
GROUP BY절을 이용하지 않고 함수의 인수로 지정한 속성을 범위로 하여 속성의 값을 집계한다.

| 부서  | 이름 | 상여내역 | 상여금 |
| ---- | ---- | ---- | ---- | 
| 기획 | 홍길동| 연장근무|100|
| 기획 | 일지매| 연장근무|100|
| 기획 | 최준호| 야간근무|120|
| 기획 | 장길산| 특별근무|90|
| 인터넷|강건달| 특별근무|90|
| 인터넷|서국현| 특별근무|90|
| 인터넷|박인식| 연장근무|30|
| 편집|김선달| 특별근무|80|
| 편집|황종근| 연장근무|40|
| 편집|성춘향| 야간근무|80|
| 편집|임꺽정| 야간근무|80|
| 편집|황진이| 야간근무|50|

예제1) <상여금>테이블에서 '상여내역'별로 '상여금'에 대한 일련 번호를 구하시오.(단, 순서는 내림차순이며 속성명은 NO로 할것)
<pre><code>SELECT 상여내역, 상여금,
ROW_NUMBER() OVER (PARTITION BY 상여내역 ORDER BY 상여금 DESC) AS NO
FROM 상여금;
</code></pre>

 예제2) <상여금>테이블에서 '상여내역'별로 '상여금'에 대한 순위를 구히송. (단, 순서는 내림차순이며, 속성명은 '상여금순위'로 하고 , RANK()함수를 이용할 것)
 <pre><code>
 SELECT 상여내역, 상여금,
 RANK() OVER (PARTITION BY 상여내역 ORDER BY 상여금 DESC) AS 상여금 순위
 FROM 상여금 ;
 </code></pre>
 
 <h1> 그룹 지정 검색</h1>
 GROUP BY 절에 지정한 속성을 기준으로 자료를 그룹화하여 검색한다.
 
 예제1) <상여금> 테이블에서 '부서'별 '상여금'의 평균을 구하시오
 <pre><code>SELECT 부서, AVG(상여금) AS 평균
 FROM 상여금
 GROUP BY 부서;</code></pre>
 
 예제2) <상여금>테이블에서 부서별 튜플 수를 검색하시오.
 <pre><code>SELECT 부서, COUNT(*) AS 사원수
 FROM 상여금
 GROUP BY 부서;</code></pre>
 |부서|사원수|
 |----|-----|
 |기획|  4  |
 |인터넷|3|
 |편집|5|
 
 예제3) <상여금>테이블에서 '상여금'이 100 이상인 사원이 2명 이상인 '부서'의 튜플 수를 구하시오.
 <pre><code>SELECT 부서, COUNT(*)AS 사원수
 FROM 상여금
 WHERE 상여금 >= 100
 GROUP BY 부서
 HAVING COUNT(*) >=2;
 </code></pre>
 
 |기획|  3  |
 
 예제4) <상여금> 테이블의 '부서','상여내역', 그리고 '상여금'에 대해 부서별 상여내역별 소계와 전체 합계를 검색하시오. (단, 속성명은 '상여금합계'로 하고 ROLLUP함수를 사용할 것) 
 <pre><code>SELECT 부서, 상여내역, SUM(상여금) AS 상여급합계
 FROM 상여금
 GROUP BY ROLLUP(부서, 상여내역);
 </code></pre>
 
 예제5) <상여금>테이블의 '부서','상여내역', 그리고 '상여금'에 대해 부서별 상여내역별 소계와 전체 합계를 검색하시오.
 (단, 속성명은 '상여금합계'로 하고 CUBE함수를 사용할 것)
 <pre><code>
 SELECT 부서, 상여내역, 상여금 AS 상여급합계
 FROM 상여금
 GROUP BY CUBE(부서, 상여내역);
 </code></pre>
 
 <h1>집합 연산자를 이용한 통합 질의</h1>
 집합연산자를 사용하여 2개 이상의 테이블의 데이터를 하나로 통합한다.
 
 * UNION : 두 SELECT문의 조회 결과를 통합하여 모두 출력한다.<br>중복된 행은 한번만 출력한다
 * UNION ALL : 두 SELECT문의 조회 결과를 통합하여 모두 출력한다.<br>중복된 행도 그대로 출력한다
 * INTERSECT : 두 SELECT 문의 조회 결과 중 공통된 행만 출력한다. (교집합)
 * EXCEPT : 첫 번째 SELECT문의 조회 결과에서 두 번째 SELECT문의 조회 결과를 제외한 행을 출력한다. (차집합)


 |사원|직급|
 |----|-----|
 |김혜영|팀장|
 |김현숙|과장|
 |김지혜|대리|
 |이관민|대리|
 |우지훈|주임|
 |신선미|주임|
 |김단희|주임|
 |한주연|주임|
 |이하림|인턴|
 |윤유정|근로|

 |사원|직급|
 |----|-----|
 |신원섭|이사|
 |이성호|대리|
 |홍영선|과장|
 |류기선|부장|
 
 예제1) <문화기획팀>테이블과 <직원> 테이블을 통합하는 질의문을 작성하시오. (단, 같은 레코드가 중복되어 나오지 않게 하시오)
 <pre><code>SELECT *
 FROM 문화기획팀
 UNION
 SELECT *
 FROM 직원;</code></pre>
 
 예제2) <문화기획팀>테이블과 <직원> 테이블에 공통으로 존재하는 레코드만 통합하는 질의문을 작성하시오.
 <pre><code>SELECT*
 FROM 문화기획팀
 INTERSECT
 SELECT *
 FROM 직원
 </code></pre>
 
 <h1>DML-JOIN</h1>
 <h3>INNER JOIN</h3>
 <h4> EQUI JOIN</h4>
 
 예제1) <학생>테이블과 <학과>테이블에서 "학과코드" 값이 같은 튜플을 JOIN하여 '학번','이름','학과코드','학과명'을 출력하는 SQL문을 작성하시오.
 <pre><code>SELECT 학번, 이름, 학생.학과코드, 학과명
 FROM 학생, 학과코드
 WHERE 학생.학과코드=학과.학과코드;
 
 SELECT 학번, 이름, 학생.학과코드, 학과명
 FROM 학생 NATURAL JOIN 학과;
 
 SELECT 학번, 이름, 학생.학과코드, 학과명
 FROM 학생 JOIN 학과 USING(학과코드);
 </code></pre>
 
 <h4>NO-EQUI JOIN</h4>
 예제)<학생>테이블과 <성적등급>테이블을 join하여 각 학생의 학번, 이름, 성적, 등급을 출력하는 SQL문을 작성하시오.
 
 <pre><code>
 SELECT 학번, 이름, 성적, 등급
 FROM 학생, 성적등급
 WHERE 학생.성적 BETWEEN 성적등급.최저 AND 성적등급.최고;
 </code></pre>
 
 <h1> OUTER JOIN </h1>
 OUTER JOIN은 릴레이션에서 JOIN조건에 만족하지 않는 튜플도 결과로 출력하기 위한 JOIN방법으로 LEFT OUTER, RIGHT OUTER JOIN, FULL OUTER JOIN이 있다.
 > LEFT OUTER JOIN: INNER JOIN 결과를 구한 후, 우측 항 릴레이션의 어떤 튜플과도 맞지 않는 좌측 항의 릴레이션에 있는 튜플들에 NULL값을 붙여서 INNER JOIN결과에 추가한다.

예제1) <학생> 테이블과 <학과> 테이블에서 '학과코드' 값이 같은 튜플을 JOIN하여 학번, 이름, 학과코드, 학과명을 출력하는 SQL문을 작성하시오. 이때 학과코드가 입력되지 않은 학생도 출력하시오.
<pre><code>SELECT 학번, 이름, 학과코드, 학과명
FROM 학생 LEFT OUTER JOIN 학과
ON 학생.학과코드=학과.학과코드

SELECT 학번, 이름, 학생.학과코드, 학과명
FROM 학생, 학과
WHERE 학생.학과코드=학과.학과코드(+);</code></pre>

예제2)<학생> 테이블과 <학과> 테이블에서 '학과코드'값이 같은 튜플을 JOIN하여 학번,이름,학과코드,학과명을 출력하는 SQL문을 작성하시오. 이때, 학과코드가 입력 안 된 학생이나 학생이 없는 학과코드도 모두 출력하시오.
<pre><code>
SELECT 학번,이름,학과코드,학과명
FROM 학생 FULL OUTER JOIN 학과
ON 학생.학과코드 = 학과.학과코드;
</code></pre>


<h1>SELF JOIN</h1>
SELF JOIN은 같은 테이블에서 2개의 속성을 연결하여 EQUI JOIN을 하는 JOIN방법이다.
예1)<학생>테이블을 SELF JOIN하여 선배가 있는 학생과 선배의 이름을 표시하는 SQL문을 작성하시오.
<pre><code>
SELECT A.학번,A.이름,B.이름 AS선배
FROM 학생 A JOIN 학생B
ON A.선배=B.학번;

SELECT A.학번, A.이름, B.이름 AS 선배
FROM 학생A, 학생B
WHERE A.선배=B.학번;

</code></pre>

 
